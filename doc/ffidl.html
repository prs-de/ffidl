<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <link rel="author" href="mailto:rec@elf.org">
    <link rel="stylesheet" href="styles.css">
    <meta name="GENERATOR" content="Roger E Critchlow Jr">
    <meta name="DESCRIPTION" content="Tcl/Tk Foreign Function Call Extension">
    <title>Ffidl</title>
  </head>
  <body>
    <header>
      <h1>Ffidl</h1>
      <p>Extend Tcl without extensions</p>
    </header>
    <div class="wrapper">
      <nav>
        <ul>
          <li>
            <h3>
              <a href="#introduction">Introduction</a>
            </h3>
          </li>
          <li>
            <h3>
              <a href="#changelog">Changelog</a>
            </h3>
          </li>
          <li>
            <h3>
              <a href="#commands">Commands, et al.</a>
            </h3>
            <ul>
              <li><a href="#::ffidl::callout">::ffidl::callout</a></li>
              <li><a href="#::ffidl::callback">::ffidl::callback</a></li>
              <li><a href="#::ffidl::symbol">::ffidl::symbol</a></li>
              <li><a href="#::ffidl::stubsymbol">::ffidl::stubsymbol</a></li>
              <li><a href="#::ffidl::typedef">::ffidl::typedef</a></li>
              <li><a href="#::ffidl::info">::ffidl::info</a></li>
              <li><a href="#::ffidl_pointer_pun">::ffidl_pointer_pun</a></li>
              <li><a href="#::ffidl::find-lib">::ffidl::find-lib</a></li>
              <li><a href="#::ffidl::find-type">::ffidl::find-type</a></li>
            </ul>
          </li>
          <li><h3><a href="#types">Types</a></h3></li>
          <li><h3><a href="#install">Install</a></h3></li>
          <li><h3><a href="#demos">Demos</a></h3></li>
          <li><h3><a href="#performance">Performance</a></h3></li>
          <li><h3><a href="#issues">Issues</a></h3></li>
          <li><h3><a href="#credits">Credits</a></h3></li>
          <li><h3><a href="#copyright">Copyright</a></h3></li>
          <li><h3><a href="#license">License</a></h3></li>
          <li><h3><a href="#warranty">No Warranty</a></h3></li>
        </ul>
      </nav>
      <section>
        <h2 id="introduction">Ffidl</h2>
        <p>
          Ffidl allows you to call C
          functions using pure Tcl wrappers. You specify a function name, a
          library, a list of argument types, and a return type, and Ffidl
          takes care of the nasty details of converting a Tcl command call
          into a C function call for you. So, if you have a shared library
          and a specification of the entries in the library, you can wrap
          the library into a Tcl extension with Ffidl and pure Tcl.
        </p>
        <p>
          The following example shows how to invoke libc's <code>puts(3)</code>
          function from Tcl code:
        </p>
        <pre><code>% package require Ffidl
0.8b0
% ffidl::callout cputs {pointer-utf8} int [ffidl::symbol libc.so.6 puts]
% cputs "Hello libc!"
Hello libc!
12</code></pre>
        <p>
          Ffidl can use the
          latest <a href="https://sourceware.org/libffi">libffi</a> (version
          3.3 at the time of this writing) to dynamically construct calls to C
          functions from Tcl, to dynamically construct calls from C functions
          into Tcl. Libffi runs on many platforms, see Supported Platforms
          section on <a href="https://sourceware.org/libffi">libffi</a>'s
          website for details.
        </p>
        <p>
          Ffidl can also be configured (<code>--with-libffcall</code>) to use
          <a href="https://www.gnu.org/software/libffcall/">libffcall</a> a
          GPL'ed foreign function package which implements both callouts and
          callbacks on many platforms.  Versions 1.13 and 2.1 have been tested
          to work.
        </p>
        <p>
          Ffidl uses Tcl's <code>Tcl_LoadFile</code>
          and <code>Tcl_FindSymbol</code>, to load dynamic libraries and
          discover the locations of functions.
        </p>
        <p>
          Ffidl should be able to run on any system with a stubs enabled Tcl,
          libffi or libffcall support, and a libdl implementation.
        </p>
        <p>
          Ffidl 0.8b0 is an alpha release. There are configuration details
          which you will need to attend to by hand in the current release.
          The initial development turned up a few bugs in libffi under
          linux-x86, so users on other architectures should be alert for
          similar problems. There are several open design issues still to
          be resolved, so there may be changes in the interfaces in future
          releases.
        </p>
        <p>
          Assistance is needed to verify that the implementation works on all
          the architectures supported by libffi and libffcall, and the open
          design issues could use some discussion.
        </p>
      </section>
      <section class="warning">
        <h2 id="warning">API Compatibility Warning</h2>
        <p>
          The Ffidl API is subject to change in incompatible ways.  In
          particular, it might be changed to improve support for declaring and
          accessing structs, enums, pointers and byte buffers, and to integrate
          better with Tcl's API.
        </p>
        <p>
          Always check the <a href="#changelog">Changelog</a> before updating.
        </p>
      </section>
      <section>
        <h2 id="changelog">Changelog</h2>
        <h3>Ffidl 0.8b0 (pre-release)</h3>
        <p>
          Ffidl 0.8b0 has the following changes:
        </p>
        <ul>
          <li><i>Feat</i> support for LLP64 (Windows 64bit)</li>
          <li><i>Feat</i> support for specifying callback's command prefix</li>
          <li><i>Feat</i> return callback's function address</li>
          <li><i>Feat</i> simplify build system using pkg-config</li>
          <li><i>Feat</i> add <code>ffidl::info NULL</code> that returns the
          value of <code>NULL</code> pointers for the architecture</li>
          <li><i>Feat</i> support specifying library binding time and symbol
          visibility</li>
          <li><i>Feat</i> Documentation improvements</li>
          <li><i>Fix</i> check protocol name on non-Windows platforms</li>
          <li><i>Fix</i> misuse of libffi's return value API</li>
          <li><i>Fix</i> double-free upon deleting interpreter</li>
          <li><i>Fix</i> various memory leaks</li>
          <li><i>Fix</i> crash when retrieving <code>void</code>'s format </li>
          <li><i>Fix</i> test's usage of uninitialized global variables</li>
          <li><i>Fix</i> deleting slave interpreters when <code>USE_TCL_LOADFILE</code></li>
          <li><i>Fix</i> disable <code>long double</code> support if longer
          than <code>double</code></li>
          <li><i>Fix</i> building with MinGW</li>
          <li><i>Fix</i> <b>Ffidlrt</b> no longer requires libc</li>
        </ul>
        <p>
          The changes in 0.8b0 were implemented
          by <a href="mailto:adrian@medranocalvo.com">Adri치n Medra침o Calvo</a>
          for <a href="https://www.prs.de">Patzschke + Rasp Software GmbH</a>,
          and are under BSD License; do not contact the original Ffidl author
          for support about them.
        </p>
        <h3>Ffidl 0.7</h3>
        <p>
          Ffidl 0.7 has the following changes since 0.6:
        </p>
        <ul>
          <li>updates for 2015 version of libffi
          </li>
          <li>support for Tcl 8.6
          </li>
        </ul>
        <p>
          The changes in 0.7 were implemented
          by <a href="mailto:adrian@medranocalvo.com">Adri치n Medra침o Calvo</a>
          for <a href="https://www.prs.de">Patzschke + Rasp Software GmbH</a>,
          and are under BSD License; do not contact the original Ffidl author
          for support about them.
        </p>
        <h3>Ffidl 0.6</h3>
        <p>
          Ffidl 0.6 has the following changes since 0.5:
        </p>
        <ul>
          <li>updates for 2005 versions of libffi &amp; ffcall
          </li>
          <li>TEA 3.2 buildsystem, testsuite
          </li>
          <li>support for Tcl 8.4, Tcl_WideInt, TclpDlopen
          </li>
          <li>support for Darwin PowerPC
          </li>
          <li>fixes for 64bit (LP64)
          </li>
          <li>callouts &amp; callbacks are created/used relative to current
            namespace (for unqualified names)
          </li>
          <li>addition of <a href=
                             "#::ffidl::stubsymbol">::ffidl::stubsymbol</a> for Tcl/Tk symbol
            resolution via stubs tables
          </li>
          <li>callbacks can be called anytime, not just from inside
            callouts (using Tcl_BackgroundError to report errors)
          </li>
        </ul>
        <p>
          The changes in 0.6 were implemented by Daniel A. Steffen, are
          Copyright &copy; 2005 by Daniel A. Steffen and are under BSD License;
          do not contact the original Ffidl author for support about them.
        </p>
        <p>
          Ffidl 0.6 has been verified to build and pass its testsuite on
          the following platforms:
        </p>
        <ul>
          <li>Mac OS X 10.3
          </li>
          <li>Windows XP (with MinGW 3.1.0-1)
          </li>
          <li>x86 Fedora Linux FC2, Linux 2.6 kernel
          </li>
          <li>x86 Debian GNU/Linux 2.2, Linux 2.4 kernel
          </li>
          <li>x86 Sun Solaris 9
          </li>
          <li>x86 FreeBSD 4.8
          </li>
          <li>x86 NetBSD 1.6.1
          </li>
          <li>AMD 64bit Fedora Core release 3 , Linux 2.6 kernel
          </li>
          <li>DEC Alpha Debian GNU/Linux 3.0, Linux 2.2 kernel
          </li>
        </ul>
        <h3>Ffidl 0.5</h3>
        The original Ffidl, created by <a href="mailto:rec@elf.org">Roger E
        Critchlow Jr</a>.  Please, refer
        to <a href="http://elf.org/ffidl/">Ffidl 0.5</a> for details.
      </section>
      <section id="commands">
        <h2>Commands, Functions, and Procs</h2>
        <p>
          Ffidl defines seven Tcl commands in the <b>Ffidl</b> package:
          <a href="#::ffidl::callout">::ffidl::callout</a>,
          <a href="#::ffidl::callback">::ffidl::callback</a>,
          <a href="#::ffidl::library">::ffidl::library</a>,
          <a href="#::ffidl::symbol">::ffidl::symbol</a>,
          <a href="#::ffidl::stubsymbol">::ffidl::stubsymbol</a>,
          <a href="#::ffidl::typedef">::ffidl::typedef</a>, and
          <a href="#::ffidl::info">::ffidl::info</a>; exports one function from the
          <b>Ffidl</b> shared library:
          <a href="#ffidl_pointer_pun">ffidl_pointer_pun</a>; and defines two
          helper procs in the <b>Ffidlrt</b> package in
          <b>demos/ffidlrt.tcl</b>: <a href="#::ffidl::find-lib">::ffidl::find-lib</a>,
          and <a href="#::ffidl::find-type">::ffidl::find-type</a>, which are currently
          just stubs of their true form.
        </p>
        <p>
          These interfaces should be considered subject to revision.
        </p>
        <dl>
          <dt id="::ffidl::callout">
            <b>::ffidl::callout</b>
            <i>name</i>
            {<i>?arg_type1 ...?</i>}
            <i>return_type</i>
            <i>address</i>
            <i>?protocol?</i>
          </dt>
          <dd>
            <p>
              <b>::ffidl::callout</b> defines a Tcl command with the
              specified <i>name</i> which, when invoked, converts its
              arguments according to the <i>arg_types</i> specified, calls
              the function at the specified <i>address</i>, and converts the
              specified <i>return_type</i> into a Tcl result. The allowed
              <a href="#types">types</a> are described below.
            </p>
            <p>
              The <i>protocol</i> specifies a calling convention to be
              used. Depending on the platform, any of the following values can
              be used: <code>default</code>, <code>efi64</code>, <code>fastcall</code>,
              <code>gnuw64</code>, <code>mscdecl</code>, <code>pascal</code>,
              <code>register</code>, <code>stdcall</code>, <code>cdecl</code>,
              <code>sysv</code>, <code>thiscall</code>, <code>unix64</code> or
              <code>win64</code>.
            </p>
          </dd>
          <dt id="::ffidl::callback">
            <b>::ffidl::callback</b>
            <i>name</i>
            {<i>?arg_type1 ...?</i>}
            <i>return_type</i>
            <i>?protocol?</i>
            <i>?cmdprefix?</i>
          </dt>
          <dd>
            <p>
              <b>::ffidl::callback</b> declares that a Tcl proc with the
              specified <i>name</i> will be invoked as a callback from C
              code. When invoked the arguments will be converted to Tcl
              values according to the <i>arg_types</i> specified, passed to
              <i>name</i>, the return value from <i>name</i> will be
              converted back into the specified <i>return_type</i>, and the
              value will be returned to the caller. The allowed
              <a href="#types">types</a> are described below.
            </p>
            <p>
              Returns a function pointer to the created callback.
            </p>
            <p>
              The <i>protocol</i> specifies a calling convention to be
              used.  For supported values, please
              see <a href="#ffidl::callout">ffidl::callout</a>.
            </p>
            <p>
            The <i>cmdprefix</i> specifies a command prefix to be invoked
            instead of the proc with the specified name.  The arguments are
            appended to the command prefix before evaluation.
            </p>
          </dd>
          <dt id="::ffidl::library">
            <b>::ffidl::library</b>
            <i>?-binding now|lazy?</i>
            <i>?-visibility local|global?</i>
            <i>?--?</i>
            <i>library</i>
          </dt>
          <dd>
            <p>
              <b>::ffidl::library</b> load a dynamically linked library of name <i>library</i>.
              The option <i>-binding</i> determines whether the symbols bound on use or immediately.
              The option <i>-visibility</i> determines whether the bound symbols are available to further loaded libraries.
              Note that this options are not supported under all Ffidl
              configurations.  When they are not specified, the platform's default
              for the Ffidl configuration is used.
            </p>
          </dd>
          <dt id="::ffidl::symbol">
            <b>::ffidl::symbol</b>
            <i>library</i>
            <i>symbol</i>
          </dt>
          <dd>
            <p>
              <b>::ffidl::symbol</b> loads, if necessary, a dynamically
              linked library of name <i>library</i> and fetches the loaded
              address of <i>symbol</i> from the library. The kinds of
              <i>symbols</i> available vary with the implementation of
              dynamic loading.
            </p>
          </dd>
          <dt id="::ffidl::stubsymbol">
            <b>::ffidl::stubsymbol</b>
            <i>library</i>
            <i>stubstable</i>
            <i>symbolnumber</i>
          </dt>
          <dd>
            <p>
              <b>::ffidl::stubsymbol</b> returns the address of the symbol
              indexed by <i>symbolnumber</i> in the <i>library</i>'s stubs
              table <i>stubstable</i>.
            </p>
            <p>
              <i>library</i> can be one of <code>tcl</code> or <code>tk</code> and
              <i>stubstable</i> can be one of <code>stubs</code>,
              <code>intStubs</code>, <code>platStubs</code>, <code>intPlatStubs</code> or
              <code>intXLibStubs</code>.
            </p>
          </dd>
          <dt id="::ffidl::typedef">
            <b>::ffidl::typedef</b>
            <i>name</i>
            <i>type1 ?...?</i>
          </dt>
          <dd>
            <p>
              <b>::ffidl::typedef</b> defines a new Ffidl type name. This may
              be either a simple alias for an existing type, or a list of
              types which form a structured aggregate. To pass a structure by
              value or return a structure by value, you must make a
              <b>::ffidl::typedef</b> for it. But even if you only pass or
              receive structures by reference, you might want to define a
              structure in order to use the <b>format</b>, <b>sizeof</b>, and
              <b>alignof</b> options of <a href="#::ffidl::info">::ffidl::info</a>
              on it.
            </p>
          </dd>
          <dt id="::ffidl::info">
            <b>::ffidl::info</b>
            <i>option</i>
            <i>?...?</i>
          </dt>
          <dd>
            <p>
              <b>::ffidl::info</b> implements a variety of information
              functions.
            </p>
            <dl>
              <dt>
                <b>::ffidl::info alignof</b> <i>type</i>
              </dt>
              <dd>
                returns the alignment modulus for <i>type</i>.
              </dd>
              <dt>
                <b>::ffidl::info callbacks</b>
              </dt>
              <dd>
                returns a list of callbacks defined with <a href="#::ffidl::callback">::ffidl::callback</a>.
              </dd>
              <dt>
                <b>::ffidl::info callouts</b>
              </dt>
              <dd>
                returns a list of callouts defined with <a href="#::ffidl::callout">::ffidl::callout</a>.
              </dd>
              <dt>
                <b>::ffidl::info canonical-host</b>
              </dt>
              <dd>
                returns the canonical host name as determined by autoconf.
              </dd>
              <dt>
                <b>::ffidl::info format</b> <i>type</i>
              </dt>
              <dd>
                returns a format string for <i>type</i>, in the style of
                the Tcl <b>binary format</b> and <b>binary scan</b>
                commands, using the correct endian format for integers and,
                for structures, including any pad bytes required for
                alignment of fields.
              </dd>
              <dt>
                <b>::ffidl::info have-int64</b>
              </dt>
              <dd>
                returns true if the host implements a 64 bit integer.
              </dd>
              <dt>
                <b>::ffidl::info have-long-double</b>
              </dt>
              <dd>
                returns true if the host implements the <code>long double</code> type.
              </dd>
              <dt>
                <b>::ffidl::info have-long-long</b>
              </dt>
              <dd>
                returns true if the host implements the <code>long long</code> type.
              </dd>
              <dt>
                <b>::ffidl::info interp</b>
              </dt>
              <dd>
                returns the current <code>Tcl_Interp</code> as an integer value.
              </dd>
              <dt>
                <b>::ffidl::info libraries</b>
              </dt>
              <dd>
                returns the list of libraries opened by
                <a href="#::ffidl::library">::ffidl::library</a> or
                <a href="#::ffidl::symbol">::ffidl::symbol</a>.
              </dd>
              <dt>
                <b>::ffidl::info signatures</b>
              </dt>
              <dd>
                returns the list of function call signatures used by
                <a href="#::ffidl::callout">::ffidl::callout</a>.
              </dd>
              <dt>
                <b>::ffidl::info sizeof</b> <i>type</i>
              </dt>
              <dd>
                returns the size of <i>type</i>.
              </dd>
              <dt>
                <b>::ffidl::info typedefs</b>
              </dt>
              <dd>
                returns a list of types defined
                with <a href="#::ffidl::typedef">::ffidl::typedef</a>.
              </dd>
              <dt>
                <b>::ffidl::info use-callbacks</b>
              </dt>
              <dd>
                returns true if Ffidl was configured to use callbacks.
              </dd>
              <dt>
                <b>::ffidl::info use-libffcall</b>
              </dt>
              <dd>
                returns true if Ffidl was configured to use libffcall.
              </dd>
              <dt>
                <b>::ffidl::info use-libffi</b>
              </dt>
              <dd>
                returns true if Ffidl was configured to use libffi.
              </dd>
              <dt>
                <b>::ffidl::info use-libffi-raw</b>
              </dt>
              <dd>
                returns true if libffi implements the raw api.
              </dd>
              <dt>
                <b>::ffidl::info NULL</b>
              </dt>
              <dd>
                returns the null pointer value.
              </dd>
            </dl>
          </dd>
          <dt id="::ffidl_pointer_pun">
            EXTERN void
            *<b>ffidl_pointer_pun</b>(void *<i>pointer</i>);
          </dt>
          <dd>
            <b>ffidl_pointer_pun</b> is exported from the Ffidl shared lib
            to allow conversions between pointer representations to be
            coded as Ffidl bindings. There are some examples in
            <b>ffidlrt.tcl</b>.
          </dd>
          <dt id="::ffidl::find-lib">
            <b>::ffidl::find-lib</b>
            <i>library</i>
          </dt>
          <dd>
            <b>::ffidl::find-lib</b> converts a conventional name for a
            library into the path name for the library name appropriate to
            the host system. It is currently implemented in
            <b>ffidlrt.tcl</b> as a table lookup which returns the
            libraries appropriate to my Linux system.
          </dd>
          <dt id="::ffidl::find-type">
            <b>::ffidl::find-type</b>
            <i>type</i>
          </dt>
          <dd>
            <b>::ffidl::find-type</b> converts a standard types such as
            <b>size_t</b> and <b>time_t</b> into real types appropriate to
            the host system. It is currently implemented in
            <b>ffidlrt.tcl</b> as a table lookup which returns the types
            appropriate to my Linux system.
          </dd>
        </dl>
      </section>
      <section>
        <h2 id="types">Types</h2>
        <p>
          The Ffidl builtin types include the scalar C types in both their
          unsized forms and as explicitly bit sized types, and a variety of
          pointer treatments. Note that some types are only valid in
          certain contexts: arguments (arg), return (ret), or struct
          elements (elt).
        </p>
        <p>
          In addition to the builtin types,
          the <a href="#::ffidl::typedef">::ffidl::typedef</a>
          command may be used to define new types. Aliases for existing
          types may be used where ever the existing type may be used.
          Structured aggregates may be used as arguments, returns, or
          elements of other structures.
        </p>
        <table id="typetable">
          <tr>
            <th colspan="2">
              <abbr title="Whether the type can be used in a callout.">
                callout
              </abbr>
            </th>
            <th colspan="2">
              <abbr title="Whether the type can be used in a callback.">
                callback
              </abbr>
            </th>
            <th rowspan="2">
              <abbr title="Whether the type can be used as an element of a struct.">
                elt
              </abbr>
            </th>
            <th rowspan="2">
              type
            </th>
            <th rowspan="2">
              definition
            </th>
          </tr>
          <tr>
            <th>
              <abbr title="Callout's argument type.">
                arg
              </abbr>
            </th>
            <th>
              <abbr title="Callout's return type.">
                ret
              </abbr>
            </th>
            <th>
              <abbr title="Callback's argument type.">
                arg
              </abbr>
            </th>
            <th>
              <abbr title="Callback's return type.">
                ret
              </abbr>
            </th>
          </tr>
          <tr> <td> &cross; </td> <td> &check; </td> <td> &cross; </td> <td> &check; </td> <td> &cross; </td> <td> <code>void</code> </td> <td> void </td> </tr>
          <tr> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> <code>char</code> </td> <td> char </td> </tr>
          <tr> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> <code>signed&nbsp;char</code> </td> <td> signed char </td> </tr>
          <tr> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> <code>unsigned&nbsp;char</code> </td> <td> unsigned char </td> </tr>
          <tr> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> <code>int</code> </td> <td> int </td> </tr>
          <tr> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> <code>unsigned</code> </td> <td> unsigned int </td> </tr>
          <tr> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> <code>short</code> </td> <td> signed short int </td> </tr>
          <tr> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> <code>unsigned&nbsp;short</code> </td> <td> unsigned short int </td> </tr>
          <tr> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> <code>long</code> </td> <td> signed long int </td> </tr>
          <tr> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> <code>unsigned&nbsp;long</code> </td> <td> unsigned long int </td> </tr>
          <tr> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> <code>float</code> </td> <td> float </td> </tr>
          <tr> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> <code>double</code> </td> <td> double </td> </tr>
          <tr> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> <code>long&nbsp;long</code> </td> <td> long long </td> </tr>
          <tr> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> <code>unsigned&nbsp;long&nbsp;long</code> </td> <td> unsigned long long </td> </tr>
          <tr> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> <code>long&nbsp;double</code> </td> <td> long double </td> </tr>
          <tr> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> <code>sint8</code> </td> <td> signed 8 bit int </td> </tr>
          <tr> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> <code>uint8</code> </td> <td> unsigned 8 bit int </td> </tr>
          <tr> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> <code>sint16</code> </td> <td> signed 16 bit int </td> </tr>
          <tr> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> <code>uint16</code> </td> <td> unsigned 16 bit int </td> </tr>
          <tr> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> <code>sint32</code> </td> <td> signed 32 bit int </td> </tr>
          <tr> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> <code>uint32</code> </td> <td> unsigned 32 bit int </td> </tr>
          <tr> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> <code>sint64</code> </td> <td> signed 64 bit int </td> </tr>
          <tr> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> <code>uint64</code> </td> <td> unsigned 64 bit int </td> </tr>
          <tr> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> <code>pointer</code> </td> <td> pointer as an integer value </td> </tr>
          <tr> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &cross; </td> <td> <code>pointer-obj</code> </td> <td> pointer from Tcl_Obj </td> </tr>
          <tr> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &cross; </td> <td> &cross; </td> <td> <code>pointer-utf8</code> </td> <td> pointer from String </td> </tr>
          <tr> <td> &check; </td> <td> &check; </td> <td> &check; </td> <td> &cross; </td> <td> &cross; </td> <td> <code>pointer-utf16</code> </td> <td> pointer from Unicode </td> </tr>
          <tr> <td> &check; </td> <td> &cross; </td> <td> &cross; </td> <td> &cross; </td> <td> &cross; </td> <td> <code>pointer-byte</code> </td> <td> pointer from ByteArray </td> </tr>
          <tr> <td> &check; </td> <td> &cross; </td> <td> &cross; </td> <td> &cross; </td> <td> &cross; </td> <td> <code>pointer-var</code> </td>
            <td>
              pointer from ByteArray stored in variable. If the ByteArray
              is shared, then an unshared copy is made and stored back into
              the variable.
            </td>
          </tr>
          <tr> <td> &cross; </td> <td> &cross; </td> <td> &cross; </td> <td> &cross; </td> <td> &cross; </td> <td> <code>pointer-proc</code> </td> <td> pointer to callback function constructed to call a Tcl proc. </td> </tr>
          <tr> <td> &cross; </td> <td> &cross; </td> <td> &cross; </td> <td> &cross; </td> <td> &cross; </td> <td> <code>struct</code> </td> <td> structure aggregate </td> </tr>
        </table>
      </section>
      <section>
        <h2 id="install">Installation</h2>
        <h3>Download</h3>
        <p>
          The latest release can be downloaded from the following links:
        </p>
        <ul>
          <li>
            <a href="https://github.com/prs-de/ffidl/tarball/0.8">ffidl-0.8b0.tar.gz</a>
          </li>
          <li>
            <a href="https://github.com/prs-de/ffidl/zipball/0.8">ffidl-0.8b0.zip</a>
          </li>
        </ul>
        <p>
          The main <a href="https://github.com/prs-de/ffidl">repository</a> can
          be accessed via web and <a href="http://git-scm.com">git</a>.
        </p>
        <h3>Build</h3>
        <p>
          Building on plaforms supported by TEA 3.2 should be painless.
        </p>
        <p>
          Installation is like for any other TEA extension, minimally it
          consists of:
        </p>
        <pre><code>tar xzvf ffidl-0.8.tar.gz
cd ffidl-0.8
configure &amp;&amp; make &amp;&amp; make install</code></pre>
        <p>
          Custom configure options are implemented for selecting between libffi
          and libffcall (<code>--with-libffi</code>
          and <code>--with-libffcall</code>), for excluding callbacks
          (<code>--disable-callbacks</code>) and for enabling building of the
          ffidl test functions into the extension (<code>--enable-test</code>).
        </p>
        <h4>Custom libffi or libffcall</h4>
        <p>
          Ffidl no longer
          bundles <a href="https://sourceware.org/libffi">libffi</a>
          nor <a href="https://www.gnu.org/software/libffcall/">libffcall</a>.
          Instead, the build system relies on
          <a href="https://www.freedesktop.org/wiki/Software/pkg-config/">pkgconfig</a>
          to find the needed objects.  If either library is installed in a
          non-standard location, use <code>PKG_CONFIG_PATH</code> to point
          Ffidl's build system to its location:
        </p>
        <pre><code># Build libffi
tar xzvf libffi-3.3.tar.gz
cd libffi-3.3
./configure --prefix=/some/path &amp;&amp; make &amp;&amp; make install
cd ..
# Build Ffidl
tar xzvf ffidl-0.8.tar.gz
cd ffidl-0.8
./configure PKG_CONFIG_PATH=/some/path/lib/pkgconfig &amp;&amp; make &amp;&amp; make install</code></pre>
        <h4>Building on Windows</h4>
        <p>
          The recommended setup for building for Windows is using Cygwin and
          MinGW.  Assuming Cygwin is properly installed, the following
          commands on a Cygwin terminal build Ffidl for Win64:
        </p>
        <pre><code>setup-x86_64.exe -q -P make,mingw64-x86_64-gcc-core,mingw64-x86_64-tcl,mingw64-x86_64-libffi
# Build Ffidl
tar xzvf ffidl-0.8.tar.gz
cd ffidl-0.8
./configure \
    --enable-symbols \
    --with-tcl=/usr/x86_64-w64-mingw32/sys-root/mingw/lib \
    --prefix=/some/path \
    --exec-prefix=/some/path \
    CC=x86_64-w64-mingw32-gcc.exe \
    CYGPATH='cygpath -m' \
    PKG_CONFIG_PATH=/usr/x86_64-w64-mingw32/sys-root/mingw/lib/pkgconfig</code></pre>
        <h4>Additional notes</h4>
        <p>
          On non-Darwin Unix and on Windows you should edit
          <b>library/ffidlrt.tcl</b> and look at the table of libraries in
          <b>::ffidlrt::libs</b> and the table of types in
          <b>::ffidlrt::types</b>. Either or both of these tables will
          probably need attention if you go further. You may need, for
          instance, to find, build, or install libraries for gmp and gdbm,
          or to adjust the pathnames for libc, libm, tcl, and tk.
        </p>
        <h3>Running</h3>
          <pre><code>make test</code></pre>
        <p>
          will run the Ffidl tests (when configured with <code>--enable-test</code>). It is not
          quite a systematic test suite, but it does exercise a good deal of Ffidl's
          capabilities, and it has turned up some problems with libffi.
        </p>
      </section>
      <section id="demos">
        <h2>Demos</h2>
        <p>
          The demos directory contains several small and medium size
          examples of Ffidl bindings to shared libraries, and some code for
          making comparisons to other ways of doing the same thing.
        </p>
        <table>
          <tr>
            <td>
              atol.tcl
            </td>
            <td>
              a Ffidl binding to atol() and congeners
            </td>
          </tr>
          <tr>
            <td>
              ffidlrt.tcl
            </td>
            <td>
              run time support for Ffidl bindings
            </td>
          </tr>
          <tr>
            <td>
              gdbm.tcl
            </td>
            <td>
              a Ffidl binding to gdbm-1.8
            </td>
          </tr>
          <tr>
            <td>
              getrusage.tcl
            </td>
            <td>
              a Ffidl binding to getrusage()
            </td>
          </tr>
          <tr>
            <td>
              libm.tcl
            </td>
            <td>
              a Ffidl binding to libm
            </td>
          </tr>
          <tr>
            <td>
              qsort.tcl
            </td>
            <td>
              a Ffidl binding to qsort
            </td>
          </tr>
          <tr>
            <td>
              tkphoto.tcl
            </td>
            <td>
              a Ffidl binding to the Tk photo image.
            </td>
          </tr>
          <tr>
            <td>
              pkgIndex.tcl
            </td>
            <td>
              hand built package index
            </td>
          </tr>
          <tr>
            <td>
              gmp.tcl
            </td>
            <td>
              a Ffidl binding to gmp-2.0.2
            </td>
          </tr>
          <tr>
            <td>
              gmpz.tcl
            </td>
            <td>
              arbitrary precision integers via gmp.tcl
            </td>
          </tr>
          <tr>
            <td>
              gmpq.tcl
            </td>
            <td>
              arbitrary precision rationals via gmp.tcl
            </td>
          </tr>
          <tr>
            <td>
              gmpf.tcl
            </td>
            <td>
              arbitrary precision floats via gmp.tcl
            </td>
          </tr>
          <tr>
            <td>
              test-gdbm-1.tcl
            </td>
            <td>
              a test of the gdbm binding
            </td>
          </tr>
          <tr>
            <td>
              test-gdbm-2.tcl
            </td>
            <td>
              a test of the gdbm binding
            </td>
          </tr>
          <tr>
            <td>
              test-gmpz.tcl
            </td>
            <td>
              a test of the gmpz routines
            </td>
          </tr>
          <tr>
            <td>
              time-libm.tcl
            </td>
            <td>
              a timing comparison of Ffidl and expr
            </td>
          </tr>
        </table>
        <p>
          <b>library/ffidlrt.tcl</b> will need attention unless you're
          running on Darwin. There are two functions,
          <b>::ffidl::find-lib</b> and <b>::ffidl::find-type</b>, which
          abstract library names and system typedefs out of the rest of the
          code. However, the abstraction on Unix is currently limited to
          the correct results for my Linux box. You'll need to rewrite the
          mapping for your own machine.
        </p>
        <p>
          <b>library/ffidlrt.tcl</b> also contains some examples of binding
          into the Tcl core itself.
        </p>
        <p>
          <b>demos/tkphoto.tcl</b> allows extraction and insertion of photo
          image pixels as binary data. See <b>tests/tkphoto.test</b> for an
          example.
        </p>
        <p>
          The <b>demos/other/gdbm.tcl</b> extension should be plug
          compatible with Tclgdbm0.6, a C coded Tcl extension for
          manipulating gdbm files. Since gdbm passes and returns
          structures, it also tests the Ffidl struct code.
        </p>
        <p>
          The <b>demos/other/gmp*.tcl</b> extensions make a nice example.
          The main Gmp package wraps all the exported mpz_*, mpq_*, and
          mpf_* entries from the Gnu multiple precision library. The
          subsidiary Gmp[zqf] packages use the Gmp package to define
          arbitrary precision integers, rationals, and floats which are
          represented as strings. This isn't the most efficient way to do
          arbitrary precision arithmetic, but it is convenient, it does
          avoid needing to know what type mp_limb_t and mp_size_t actually
          are, and it does show how to use the underlying library if you
          want to build something more efficient.
        </p>
      </section>
      <section id="performance">
        <h2>Performance</h2>
        <p>
          Performance appears to be excellent, but I can't take any credit
          because libffi is doing most of the work. The
          <b>demos/mathswig/time-libm.tcl</b> script compares
          <b>::ffidl::callout</b> wrapped libm functions to the Tcl expr
          versions of the same functions. You'll need to manually build the
          libmathswig0.5 dynamic library to provide a SWIG wrapped libm for
          comparison purposes. If you're running on Linux-x86 or Windows
          you can install Robin Becker's ::dll for another data point.
          <b>demos/mathswig/time-libm.tcl</b> will time them on the same
          functions.
        </p>
      </section>
      <section id="issues">
        <h2>Open Issues</h2>
        <p>
          A few issues have been closed since the initial release.
        </p>
        <p>
          The Windows port is done.
        </p>
        <p>
          Callbacks are implemented for the x86 architecture.
        </p>
        <p>
          But there are many open issues.
        </p>
        <p>
          Finding the right library is a pain. dlopen("libm.so") finds libm
          on my machine, but dlopen("libc.so") returns an error string
          decorated with binary characters while dlopen("libc.so.6") works.
          If you work with shared libraries you build yourself, it's not an
          issue, but for all the standard stuff there is no standard. In
          <b>demos/ffidlrt.tcl</b> the <b>::ffidl::find-lib</b> function
          provides an abstraction for at least removing these issues one
          layer away from your Ffidl bindings to the library, but the
          implementation of the abstraction hasn't gone farther than
          listing where I find my standard libraries.
        </p>
        <p>
          Discovering what type a type is is also a pain. Include headers
          are typically so heavily conditionalized, that one needs to
          search and search to find which typedef is actually implemented.
          In <b>demos/ffidlrt.tcl</b> the <b>::ffidl::find-type</b>
          function abstracts these issues out of the Ffidl bindings, but
          again the implementation of the abstraction will need some work.
        </p>
        <p>
          A backend for SWIG which generates Ffidl bindings might be
          useful.
        </p>
        <p>
          There are some more pointer types which ought to be defined: a
          variant of pointer-var which requires an unshared value; a
          pointer to a native character string -- but couldn't that be
          pushed back to the Tcl layer?
        </p>
        <p>
          Writing Tcl extensions with Ffidl is very much like writing C
          code in Tcl. I'm not sure what the actual required skill set is.
          But if you're not sure what you're doing, you might be in over
          your head. In any case, try not to take the core dumps
          personally.
        </p>
        <p>
          Loading snippets of code into a Tcl interpreter with Ffidl loaded
          could be very hazardous, as in downloading "Try ME!" scripts from
          the web. There is no Ffidl_SafeInit(), we'd probably need signed
          scripts to even begin to consider such a thing.
        </p>
        <p>
          I've looked at SWIG and at dll and seen that they very carefully
          duplicate any shared Tcl_Obj before attempting a conversion to
          Int or Double. I've also looked at the source for Tcl's expr
          command, and it converts objects to Double or Int and only
          duplicates shared objects when it finds a valid Int or a Double
          with an existing string representation. Ffidl only duplicates
          shared objects when processing pointer-var, though I'm open to
          explanations why it should do otherwise. It seems that if you
          pass a parameter to a typed function that you shouldn't be upset
          if the parameter is converted to that type.
        </p>
        <p>
          Hmm, this is a really pared to the bone. It would be nice for
          newbies and experimenters and the careless if Ffidl implemented a
          debugging mode which verified that constraints were observed: 1)
          that Tcl_Obj string reps were not modified, 2) that Tcl_Obj
          bytearray reps were not modified outside their allocated sizes,
          and so on. This could be done by switching in an alternate
          implementation of tcl_ffidl_call() which made copies and verified
          the constraints after the call.
        </p>
        <p>
          Some naming consistency in the demos. I seem to be reinventing my
          Ffidl extension style each time I start a new example.
        </p>
        <p>
          Some style consistency in the tests. The tests just run, some
          generate descriptions, some report what they've done, some say
          nothing, some give summaries.
        </p>
      </section>
      <section id="credits">
        <h2>Credits</h2>
        <p>
          Robin Becker's <a href=
                            "http://www.jessikat.fsnet.co.uk/docdll.html">::dll</a> package,
          which does much the same thing as Ffidl, provided the immediate
          inspiration for this work and pointed to the solution of some of
          the design issues for me. And Robin hisself has been very
          helpful.
        </p>
        <p>
          Anthony Green's <a href=
                             "http://sources.redhat.com/libffi/">libffi</a> package provided
          most of the initial implementation of Ffidl.
        </p>
        <p>
          Bruno Haible's <a
          href="https://www.gnu.org/software/libffcall/">libffcall</a> package
          for the clisp system provided an alternate implementation and a truly
          amazing example of cpp macrology.
        </p>
      </section>
      <section>
        <h2>
          <span id="copyright">Copyright</span>,
          <span id="license">License</span>, &amp;
          <span id="warranty">No Warranty</span>
        </h2>
        <p>
          Ffidl Version 0.8b0<br>
          Copyright &copy; 2015-2018 Patzschke + Rasp Software GmbH,
          Wiesbaden;<br>
          Copyright &copy; 2005 by Daniel A. Steffen;<br>
          Copyright &copy; 1999 by Roger E Critchlow Jr, Santa Fe, NM, USA.
        </p>
        <p>
          Permission is hereby granted, free of charge, to any person
          obtaining a copy of this software and associated documentation
          files (the ``Software''), to deal in the Software without
          restriction, including without limitation the rights to use,
          copy, modify, merge, publish, distribute, sublicense, and/or sell
          copies of the Software, and to permit persons to whom the
          Software is furnished to do so, subject to the following
          conditions:
        </p>
        <p>
          The above copyright notice and this permission notice shall be
          included in all copies or substantial portions of the Software.
        </p>
        <p>
          THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
          EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
          OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
          NONINFRINGEMENT. IN NO EVENT SHALL ROGER E CRITCHLOW JR BE LIABLE
          FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
          OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
          CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
          SOFTWARE.
        </p>
      </section>
    </div>
    <!-- right column content here -->
    <footer>
      <address>
        <a href="mailto:rec@elf.org">Roger E Critchlow Jr</a>
      </address>
      <address>
        <a href="mailto:das@users.sourceforge.net">Daniel A.
          Steffen</a>
      </address>
      <address>
        <a href="mailto:adrian@medranocalvo.com">Adri치n
          Medra침o Calvo</a>
      </address><!-- Created: Sun Mar 14 22:54:17 MST 1999 -->
      <!-- hhmts start -->
      Last modified: Jun 23 2020 <!-- hhmts end -->
      <address>
        <a href="http://www.elf.org">elf.org</a>
      </address>
    </footer>
  </body>
</html>
